Сборник полезных утилит для JavaScript
==

Предистория
--
Длительное время писал код на JS и при этом собирал часто используемы фрагменты кода в одном файле чтобы было легче копипастить. В итоге этот нарор разросся до того что его целесообразней было оформить как библиотеку.

Основная концепция
--
Функции такие же значения как и все остальные, следовательно их можно вычислять.

Все функции используют `this` и следовательно могут использоваться как методы. Таким образом функции вычисленые из функций так же должны использовать `this` и использоваться в качестве методов.

Большенство использованых алгоритмов используют элементарный набор возможностей. В итоге оказалось что возможности ECMAScript5 можно не использовать. Библиотека выдержана в стиле ECMAScript3.

Архитектура библиотеки предполагает использовать её как есть. Вместо модификации кода библиотеки рекомендуется использовать дополнения и расширения к ней. Любую функцию или метод можно заменить модифицированой или собственной. Так же её можно дополнять новыми возможностями и применять к ней паттерн "наследование".

Почему CoffeeScript
--
Быблиотека могла быть написана на оригинальном JavaScript, однако на CoffeeScript писать проще, короче и быстрее. В общем, не зачем создавать себе сложности.

Почти все примеры кода в данной инструкции будут на CoffeeScript. Если по ним возникнут вопросы, всегда можно зайти на [coffeescript.org] и воспользоваться вебинтерфейсом для преобразования кода в JavaScript.

Декоратор `$F`
--
Чтобы не модифицировать Function.prototype импользутеся декоратор $F. Он создаёт из функции функцию делающую то же самое, но при этом имеющую дополнительное API. Это позволяет с оригинлальной функцией работать так же как и раньше в других частях кода. Тем более что эта функция может быть экземпляром другого типа данных основаного на функциях.

Прототип-модификатор `$F.prototype`
--
Чтобы работали встроенные в JavaScript возможности ООП необходимо чтобы прототип типа данных основаного на функциях так же был функцией. Можно было бы использовать для этого произвольную функцию, но мне понадобилась функция которая прикрепляет необходимый интерфейс к существующим функциям а придумать для неё подходящее название было проблематично. Таким образом в прототип поместил функцию прикрепляющую конструктор $F к заданой функции.

Данная функция широко используется внутри библиотеки, однакто рекомендуется её использовать и в обычном коде, так как это будет оптимальней по сравнению с использованием декоратора `$F` так как при этом не создаётся вспомгательная функция. Противопоказание: использование другого подобного интерфейса, оригинальный интерфейс просто заменяется данным.

`$F.prototype.then`
--
Позвояет после выполнения текущей функции вызвать следующую с результатом работы текущей функции в качестве аргумента.

Визуально это выглядит как смена порядка применения унарных функций.
```coffeescript
do $F(->"example").then(alert)
```
работает так же как
```coffeescript
alert "example"

```

Примечание: есть предложение позволить вместе с функцией передавать дополнительно список аргументов. Целесообразность этого под вопросом, возможно это будет реализовано в дальнейшем.

`$F.prototype.catch`
--
Исключение такой же результат работы вичислительного алгоритма как и возращенное значение. Более того это неотемлемая часть API как стандартных библиотек так и многих других. Раз это результат работы, то и обрабатываться он должен как результат работы.

Функция catch устанавливает обработчик исключений вызваных функцией, что предполагает его дальнейшее использование в вычислениях.
```coffeescript
parseJSON = $F(JSON.parse).catch ->null
```
аналогично
```coffeescript
parseJSON = (str)->
	try JSON.parse str
	catch then null
```
Примечание: тут тоже можно перндавать дополнительные параметры.

`$F.prototype.bind`
--
В стандартном наборе ECMAScript5 этот метод возращает функцию, следовательно в нашем случае эта функция должна иметь соответствующее API. В ECMAScript3 этого метода нет, однако он очень полезен, следовательно должен быть частью библиотеки.

`$F.prototype.bindArgs`
--
Позволяет получить функцию в которой применены указаные аргументы.

`$F.prototype.bindArgsStrict`
--
Позволяет получить функцию игнорирующую агументы. По такому же принципу, по которому результат работы `bind` игнорирует `this`.

`$F.prototype.catchCond`
--
Часто библиотека или просто часть приложения использует в своей работе исключения. Однако в большенстве случаев их интересуют их собственные исключения, остальные предоставляются другим частям кода.
Данный метод позволяет отфильтровать возникшие исключения по условию.

`$F.prototype.catchVal`
--
Для возрата управлени через исключения часто используются специальные значения. Этот метод позволяет их учитывать.

`$F.prototype.catchType`
--
Фильтрует исключения по их типу.

`$F.prototype.loop`
--
Повторяет функцию до возникновения исключения. В некоторых случаях удобно использовать вмето циклов.

`$F.prototype.times`
--
Повторяет функцию указанное количество раз помещая результат в результирующий массив. Удобная замена для циклов.

Так же позволяет указать `this` вторым аргументом.
```coffeescript
$F(->"\t").times(10).join ""
```
работает как
```coffeescript
(for x in [0...10] then "\t").join ""
```
`$F.prototype.repeat`
--
Просто повторяет функцию заданное количество раз. Для удобства возращает её же.

`this` передаётся вторым аргументом.

`$F.prototype.curry`
--
Позволяет аргументы применять частично. Превращает функцию в цепочку функций с одним аргументом возращающих функции. Количество этих вложенностей можно задавать.

`$F.prototype.bindedCurry`
--
Применяя `curry` теряется связь с объектом для метода которого эта функция была вызвана. Чтобы устранить этот недостаток этот объект прикрепляетмя к функции при первом вызове. Таким образом результат работы каррированой функции удобно использовать в качестве метода.

`$F.prototype.curryBreak`
--
Работает наподобие `curry`, однако список аргументов разбиваент не по одному, а диапазонами. Рекомендуется использовать с API где у функций достаточно большое количество аргументов.

`$F.prototype.preprocessAll`
--
Функция более вспомогательная. Принимает функцию принимающую массив и возращающую массив. Используется для замены списка аргументов функции. Можно использовать для работы с различными API.

`$F.prototype.flip`
--
Меняет местами аргументы с указаными номерами.

`$F.prototype.preprocess`
--
Принимает фуннкии которые применяются к первым аргументам итоговой функции. Можно использовать как обёртку над различными API чтобы заменить аргументы на допустимые.

`$F.prototype.preprocessStrict`
--
Делает то же самое что и `preprocess`, только аргументы для которых не указан колбек игнорируются.

`$F.prototype.guard`
--
Проверяет результат на соответствие условию. В случае несоответствия бросает исключение типа `$F.Error`.

Примечания: Название функции возможно поменяется. Так же планируется доработать иерархию исключений в расчёте на упрощение отладки.

`$F.prototype.guardType`
--
Проверяет тип результата работы функции. В случае несоответствия бросает исключение типа `$F.Error`.

`$F.prototype.guardArguments`
--
Проверяет аргументы на соответствие условиям. В случае несоответствия бросает исключение типа `$F.Error`.

`$F.prototype.guardArgumentsTypes`
--
Проверяет типы аргументов на соответствие условиям. В случае несоответствия бросает исключение типа `$F.Error`.

`$F.prototype.zipper`
--
Порождает функцию принимающую массивы и выдающую массив элементы которого являются результатами применения исходной функции к элементам заданных маммивов.

Результат работы `zipper` может использоваться в качестве метода.

`$F.prototype.zip`
--
Объеденяет массивы данной функцией.

`$F.prototype.zipWith`
--
То же что и `zip` только первым аргумтом идёт объект который будет использоваться как `this`.

Примечание: Необходимость данной функции сомнительна, возможно она будет удалена. К тому же под сомнением её название.

`$F.prototype.objectZipper`
--
Аналог `zipper`, но для объектов. Можно указать объект приемник. В качестве приемника рекомендуется использовать один из входных параметров для модификации его полей.

`$F.prototype.zipObjects`
--
Применяет текущую функцию для объеденения объектов.

`$F.prototype.zipObjectsWith`
--
Объеденяет объекты, первым аргументом задаётся `this`

`$F.prototype.zipObjectsTo`
--
Объеденяет объекты используя первый аргумент в качестве приемника.

`$F.prototype.cell`
--
Реализует API подобное клеткам в Clojure.

Примечания: В данную библиотеку слабо вписывается, возможно будет вынесено отдельно в качестве дополнения.

`$F.commonKeys`
--
Выдаёт массив ключей общих для указаных объектов. Используется в `objectZipper`, однако полезна сама по себе.

`$F.Error`
--
Планируется набор исключений для упрощения отладки внутри библиотеки. Сейчас это только заглушка.


[coffeescript.org]:http://coffeescript.org